# 类中内联

**内联函数就是告诉编译器：“这个函数很小，每次调用它的时候，你直接把函数的代码复制到调用的地方，不要真的去调用函数了，这样可以省去函数调用的额外步骤，让程序运行得更快。**

**example：**

​	计算两个数中最大值的函数，这个函数非常简单	

```
int max(int a, int b) {
    return a > b ? a : b;
}
```

​	每次你调用 `max(3, 4)` 的时候，程序都要做几件事情：保存当前的位置，跳到 `max` 函数的位置去执行，然后再跳回来。这对于一个这么简单的函数来说，是有点浪费的

​	把这个函数声明为内联的：

```
inline int max(int a, int b) {
    return a > b ? a : b;
}
```

​	编译器会考虑直接在调用 `max` 函数的地方用它的代码替换，而不是真的去调用一个函数。就像是直接在调用的地方计算 `3 > 4 ? 3 : 4`，得到结果 `4`，而不需要跳到别的地方去执行 `max` 函数



**（1）内联函数并不总是能提高程序的速度。如果内联函数太大，它可能会导致程序体积变大，这样可能会降低缓存的效率，反而让程序变慢****

**（2）内联函数是给编译器的一个建议，编译器会根据自己的判断来决定是否内联一个函数**

**（3）在实际编程中，我们通常让编译器自动决定是否内联，因为现代编译器通常能够很好地做出这个决定**

**在头文件中声明类**

```
class A
{
public:
    void f1(int x); 

    /**
     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。
     *
     * @param x
     * @param y
     */
    void Foo(int x,int y) 	///< 定义即隐式内联函数！
    {
    
    };
    void f2(int x); 		///< 声明后，要想成为内联函数，必须在定义处加inline关键字。  
};
```

**实现文件中定义内联函数**

```
#include <iostream>
#include "inline.h"

using namespace std;

/**
 * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”
 *
 * @param x
 * @param y
 *
 * @return 
 */
int Foo(int x,int y);  // 函数声明
inline int Foo(int x,int y) // 函数定义
{
    return x+y;
}

// 定义处加inline关键字，推荐这种写法！
inline void A::f1(int x){

}

int main()
{

    
    cout<<Foo(1,2)<<endl;

}
/**
 * 编译器对 inline 函数的处理步骤
 * 将 inline 函数体复制到 inline 函数调用点处；
 * 为所用 inline 函数中的局部变量分配内存空间；
 * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
 * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。
 */

```



**`inline`函数的几个关键点：**

1. **减少函数调用开销**：对于小型函数，函数调用和返回操作可能比函数本身执行的成本更高。`inline`函数可以避免这些额外的开销，因为它们在编译时被展开。
2. **多个定义**：`inline`函数可以定义在头文件中，并且可以被包含在多个源文件中，而不会导致链接错误。这是因为`inline`函数的定义在每个包含它的文件中都是内联的，而不是作为单独的函数实体存在。
3. **编译器优化**：虽然`inline`是一个编译器指令，但是编译器并不总是遵循这个指令。如果函数体太大或者复杂，编译器可能会忽略`inline`指令，将函数作为普通函数处理。
4. **链接问题**：非`inline`函数必须有一个全局唯一的定义，如果在多个文件中定义了相同的非`inline`函数，会导致链接错误。但是，`inline`函数可以有多个定义，因为它们在每个包含它们的文件中都是局部的。
5. **头文件中的函数定义**：`inline`函数通常在头文件中定义，这样它们就可以被多个源文件包含，而不需要担心链接问题。
